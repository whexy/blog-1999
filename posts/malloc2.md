---
title: "细究内存泄露（二）"
date: "2021-12-18"
tags: Project
preview: true
hidden: true
---


大学四年间，遇到过两个有挑战性的课程项目：一个是计算机网络课程的手撸 RDT 通信，一个是操作系统课程的系统设计挑战赛。挑战赛有两大主题：一个是用 Rust 重写 xv6 内核，另一个是制作监控内存使用的工具。xv6 内核用 C 语言已经足够难写了，更不用说 Rust。为了卷赢，我们选择激流勇退。

<Callout title="🥊 秘籍：怎样卷赢" canFold content={`其实所有课程的项目都是玩具。实话说，按照需求点逐一实现业务，~~再加上把网页做好看点~~，就能拿高分。如果把业界常识（但学生不熟悉）的一些方案加来锦上添花——比如协程、容器、CI/CD，满分就轻松到手。\r\n\r\n 当然，“卷赢”是玩笑话。做课程作业的目的不是为了卷，也不是为了赢，而是为了体验和提升自我。适当的竞争在我看来反而增加了做项目的乐趣（跑到隔壁组看看他们做得怎么样，顺便请他们组里的妹子吃晚饭）。如果你在做项目的过程中感受不到乐趣，那就没必要为了卷赢而硬卷。`} />

监控内存使用的选题细分为若干小赛道：针对 Android 应用程序的、或是针对 Linux 程序的等等。现在 Android 都以 ART(JIT) 的形式跑着，去学习并分析 Android API 或 bytecode，在短短几个星期里不可能完成。于是，我们把目标放在监控 Linux 二进制程序上。Linux，Android，看似两个系统是并列关系，但在这儿不是。Android bytecode 可以视为一个指导 JVM 干活的指南。我们监控 Linux 二进制程序，包括了监测跑 Android 程序的 JVM、跑机器学习的 Python Interpreter。这比跳进用户态中某个具体场景里挖掘信息具有普适性。

教授允许我们贴合题目自由发挥。我们想做的事情有二。

1. 动态监控内存的分配情况，更细节一点，监控堆内存的分配与释放。
2. 动态监控内存的使用频率，如果一段被分配的内存长期没有使用，那么它有可能*泄露*了。


### 监测堆内存的分配与释放

在 Linux 中，使用和操作堆需要通过系统调用 `__bark` 或 `__mmap` 进行。这一过程非常繁琐，而且及其容易出错。所以 C 标准库提供了两个函数来方便程序员创建和销毁堆空间，那就是大名鼎鼎的 `malloc()` 和 `free()`。

<div className="flex flex-col space-y-2">
    <Dialog>
        马上医务工作者要来我房间做核酸检测，所以我先溜了。后续会讲到 Library 动态注入，二进制插桩，页分配器，系统调用追 踪等等一系列我们在项目中用到的方案。一定不会咕。
    </Dialog>
    <DialogBack>
        其实是我写累了。所以给博客加了一个 Preview 的功能，你可以看到页面顶端的提示语，以及首页上超链接旁边 Preview 的  标签。Preview 的文章不会进入 RSS Feed。
    </DialogBack>
</div>

## 0xFF 内存释放

使用高级语言的程序员一直在享受内存管理的便捷。不同语言有不同策略的内存管理：

- 类 C 语言：在`new`之后主动进行`delete`。
- 利用 RC 做 GC 的语言：移除了指向该内存的最后一个指针。
- 高级语言：对象的生命周期结束。

虽然大多数程序语言通过 GC 或者生命周期的方式接管了内存管理，但是程序员仍然需要做几项事情保证内存管理稳定有效地运行：

- 避免循环自引，例如在结构体里保存一个指向自己的指针。如此，使用 RC 策略的 GC 便不能将这块内存清理。
- 正确地看待生命周期。Rust 等语言会对于生命周期做检查。但在大多数语言里，悬垂引用和多次释放等问题依然存在。
