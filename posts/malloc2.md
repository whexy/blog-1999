---
title: "细究内存泄露（二）"
date: "2021-12-18"
tags: Project
preview: true
hidden: true
---



### 监测堆内存的分配与释放

在 Linux 中，使用和操作堆需要通过系统调用 `__bark` 或 `__mmap` 进行。这一过程非常繁琐，而且及其容易出错。所以 C 标准库提供了两个函数来方便程序员创建和销毁堆空间，那就是大名鼎鼎的 `malloc()` 和 `free()`。

<div className="flex flex-col space-y-2">
    <Dialog>
        马上医务工作者要来我房间做核酸检测，所以我先溜了。后续会讲到 Library 动态注入，二进制插桩，页分配器，系统调用追 踪等等一系列我们在项目中用到的方案。一定不会咕。
    </Dialog>
    <DialogBack>
        其实是我写累了。所以给博客加了一个 Preview 的功能，你可以看到页面顶端的提示语，以及首页上超链接旁边 Preview 的  标签。Preview 的文章不会进入 RSS Feed。
    </DialogBack>
</div>

## 0xFF 内存释放

使用高级语言的程序员一直在享受内存管理的便捷。不同语言有不同策略的内存管理：

- 类 C 语言：在`new`之后主动进行`delete`。
- 利用 RC 做 GC 的语言：移除了指向该内存的最后一个指针。
- 高级语言：对象的生命周期结束。

虽然大多数程序语言通过 GC 或者生命周期的方式接管了内存管理，但是程序员仍然需要做几项事情保证内存管理稳定有效地运行：

- 避免循环自引，例如在结构体里保存一个指向自己的指针。如此，使用 RC 策略的 GC 便不能将这块内存清理。
- 正确地看待生命周期。Rust 等语言会对于生命周期做检查。但在大多数语言里，悬垂引用和多次释放等问题依然存在。
