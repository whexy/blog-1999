---
title: "运行时的内存分配和使用监控"
date: "2021-12-18"
tags: Project
preview: true
---

大三下学期的操作系统课程的期末大作业。综合二进制插桩、动态库注入和内核缺页陷阱做的内存检查工具。为了卷赢，又毫不克制地加上了 Rust 写的 TUI 和 IPC。终于达成了本科 Project 满分四连冠的小目标。

<!-- more -->

<Dialog>
但是为什么这篇文章拖到了大四下学期才发布呢？
</Dialog>

## 0x00 选题

四年间遇到过两个具有挑战性的课程项目：一个是计算机网络课程的手撸 RDT 通信，一个是操作系统课程的设计挑战赛。操作系统挑战赛里有两大主题：用 Rust 写 xv6 内核，以及监控内存使用。xv6 的内核用 C 语言已经足够难写了，我们选择激流勇退。内存使用选题细分小赛道：有针对 Android 应用程序的、有针对 Linux 程序的。由于现在 Android 都以 ART(JIT) 的形式跑着，去学习并分析 Android API 或 bytecode，在短短几个星期里不可能完成。于是，我们把目标放在监控 Linux 二进制程序上。

<Callout title="🥊 怎样卷赢" content={`老学长忍不住要分享一些人生的经验。其实所有课程的项目都是玩具。实话说，按照需求点逐一实现业务，~~再加上把网页做好看点~~，就能拿高分。如果把业界视作常识（但学生想不到）的一些经验搬移到项目中——比如协程、容器、CI/CD 拿过来一顿狂吹，满分就轻松到手。\r\n\r\n 当然，“卷赢”是玩笑话。做课程作业的目的不是为了卷，也不是为了赢，而是为了体验和提升自我。适当的竞争在我看来反而增加了做项目的乐趣（跑到隔壁组看看他们做得怎么样，顺便请他们组里的妹子吃饭，一起说教授坏话）。如果你在做项目的过程中感受不到乐趣，那就没必要为了卷赢而硬卷。`} />

## 0x01 破题：监控分配内存及其使用频率

Linux，Android，看似两个系统是并列关系，但在这儿不是。Android bytecode 可以视为一个指导 JVM 干活的指南。我们监控 Linux 二进制程序，是去监测跑 Android 程序的 JVM，监测跑机器学习的 Python Interpreter。这比跳进用户态中某个具体场景里挖掘信息具有普适性。

教授允许我们贴合题目自由发挥。我们想做的事情有二。

1. 动态监控内存的分配情况，更细节一点，监控堆内存的分配与释放。
2. 动态监控内存的使用频率，如果一段被分配的内存长期没有使用，那么它有可能*泄露*了。

通俗来讲，内存泄露指一块无用内存没有被及时释放。例如程序员用了一个结构体`struct Message {user_id, ctx}`来存储用户向服务器发送的指令。服务器在经过解析、计算、响应后，用户拿到了满意的结果，结束套接字连接，关机睡大觉去了。这是结构体实例就失去了存在的意义，应该被及时释放。如果它一天后、或一个月后、乃至一年后、甚至到机房停电服务器宕机时都一直没有被释放，那么我们说程序存在内存泄露的问题。

但是我们不可能笃定内存泄露正在发生。这是因为内存泄露本质上不能被运行时动态检测。

- 在程序运行时，我怎么知道将来某段数据会不会被使用？万一哪天就得用它了呢？
- 在程序运行时，我怎么知道这段数据会不会在下一秒被另一个函数给释放了？

不过从统计的角度来看，一段长时间未被使用的内存确实会给系统带来压力（占据了计算资源）。所以检测内存的使用频率也是实用的功能。

## 0x02 内存泄露的根源：堆内存的分配与释放

### 使用堆的好处

假设你要用 C 语言处理 1000 万个矩阵，每个矩阵的大小不定。这些矩阵无法被预处理，你只能硬着头皮把它们全部加载进内存。更糟糕的是，由于计算格外的复杂，在得到结果之前，它们必须一直保留在内存里，时刻准备好被读取。你可以选择数据的存储方式：

- ❌ 局部数组 `LocalList[]`。尽管运行时在栈上创建局部动态数组是 C99 支持的行为，但是你很难把它们持续的保存下来。
- ❌ 全局数组 `GlobalList[]`。如果使用一个被初始化的全局数组，它会存储在二进制程序中的数据段 (data section) 中，你会编译出一个巨大无比的可执行文件。如果使用一个未被初始化的全局数组，操作系统会帮你在运行之前申请好内存摆在那里。但是，使用全局数组必须要预先规定好数据的大小，所以它不适合存储我们的矩阵数据。
- ✅ 动态数组 `HeapList[]`。在程序的运行过程中测量每个矩阵的大小，在堆上动态分配内存存储它们。这听起来是不错的解决方案。

我们最终会选择动态数组，在堆上进行数据的存放。其原因是堆空间可以在运行期间动态分配，非常灵活。这也是程序员青睐“堆”的原因。事实上，如果我们用面向对象的语言（例如 C++）写这个程序，你会发现 `new` 操作符正是在堆上开辟空间存放实例。

### 使用堆的坏处：导致内存泄露

虽然动态分配、灵活多变的堆内存听上去很不错，它也带来了困扰行业（尤其是巨头公司）几十年之久的问题，那就是内存泄露。

一个函数调用了返回指令后 (return)，它使用的栈空间就会自动释放。这是因为编译器确定了每个函数所占据的栈空间大小，并且自动向程序里插入了对栈帧 (sp) 寄存器的操纵指令。在运行期间，栈帧会自动加减以开辟和释放栈内存。

与之相反：堆内存在函数执行时开辟，大小不定。而且，一块堆内存可能被很多函数同时使用，编译器不敢贸然释放它。因此程序员必须要亲自管理堆内存的释放。

<div class="flex flex-col space-y-2">
    <Dialog>
    其实编译器可以找到合适的时机释放堆内存？例如在没有指针指向它的时候？
    </Dialog>
    <DialogBack>
    没错，这就是利用**引用计数**进行**垃圾回收**的原理。其实现代编译器有很多方法帮助程序员避免内存泄露。接着往下读，你就知道了！
    </DialogBack>
</div>

堆内存的释放需要程序员自行管理，而粗心的程序员很可能忘记（或懒得）释放内存，因此导致了内存泄露。

### 监测堆内存的分配与释放

在 Linux 中，使用和操作堆需要通过系统调用 `__bark` 或 `__mmap` 进行。这一过程非常繁琐，而且及其容易出错。所以 C 标准库提供了两个函数来方便程序员创建和销毁堆空间，那就是大名鼎鼎的 `malloc()` 和 `free()`。

<div class="flex flex-col space-y-2">
    <Dialog>
        马上医务工作者要来我房间做核酸检测，所以我先溜了。后续会讲到 Library 动态注入，二进制插桩，页分配器，系统调用追 踪等等一系列我们在项目中用到的方案。一定不会咕。
    </Dialog>
    <DialogBack>
        其实是我写累了。所以给博客加了一个 Preview 的功能，你可以看到页面顶端的提示语，以及首页上超链接旁边 Preview 的  标签。Preview 的文章不会进入 RSS Feed。
    </DialogBack>
</div>

## 0xFF 内存释放

使用高级语言的程序员一直在享受内存管理的便捷。不同语言有不同策略的内存管理：

- 类 C 语言：在`new`之后主动进行`delete`。
- 利用 RC 做 GC 的语言：移除了指向该内存的最后一个指针。
- 高级语言：对象的生命周期结束。

虽然大多数程序语言通过 GC 或者生命周期的方式接管了内存管理，但是程序员仍然需要做几项事情保证内存管理稳定有效地运行：

- 避免循环自引，例如在结构体里保存一个指向自己的指针。如此，使用 RC 策略的 GC 便不能将这块内存清理。
- 正确地看待生命周期。Rust 等语言会对于生命周期做检查。但在大多数语言里，悬垂引用和多次释放等问题依然存在。
