---
title: "细究内存管理（一）"
date: "2021-12-18"
tags: Project
image: /images/malloc/Title1.png
---

《细究内存管理》系列文章之首。大三下学期，我在操作系统课程的期末大作业里综合二进制插桩、动态库注入和内核缺页陷阱制作了内存检查工具。这一系列的博客文章将从原理出发探究内存泄露的本质，并且介绍如何综合常见的分析手段发掘内存泄露的根源。这篇文章里，我主要介绍了程序堆栈模式与内存管理的关系。

<!-- more -->

<Dialog>
但是为什么这篇文章拖到了大四下学期才发布呢？
</Dialog>

## 0x00 前言

大学四年间，遇到过两个有挑战性的课程项目：一个是计算机网络课程的手撸 RDT 通信，一个是操作系统课程的系统设计挑战赛。挑战赛有两大主题：一个是用 Rust 重写 xv6 内核，另一个是制作监控内存使用的工具。xv6 内核用 C 语言已经足够难写了，更不用说 Rust。为了卷赢，我们选择激流勇退。

<Callout title="🥊 秘籍：怎样卷赢" canFold content={`其实所有课程的项目都是玩具。实话说，按照需求点逐一实现业务，~~再加上把网页做好看点~~，就能拿高分。如果把业界常识（但学生不熟悉）的一些方案加来锦上添花——比如协程、容器、CI/CD，满分就轻松到手。\r\n\r\n 当然，“卷赢”是玩笑话。做课程作业的目的不是为了卷，也不是为了赢，而是为了体验和提升自我。适当的竞争在我看来反而增加了做项目的乐趣（跑到隔壁组看看他们做得怎么样，顺便请他们组里的妹子吃晚饭）。如果你在做项目的过程中感受不到乐趣，那就没必要为了卷赢而硬卷。`} />

监控内存使用的选题细分为若干小赛道：针对 Android 应用程序的、或是针对 Linux 程序的等等。现在 Android 都以 ART(JIT) 的形式跑着，去学习并分析 Android API 或 bytecode，在短短几个星期里不可能完成。于是，我们把目标放在监控 Linux 二进制程序上。

## 0x01 破题：监控分配内存及其使用频率

Linux，Android，看似两个系统是并列关系，但在这儿不是。Android bytecode 可以视为一个指导 JVM 干活的指南。我们监控 Linux 二进制程序，包括了监测跑 Android 程序的 JVM、跑机器学习的 Python Interpreter。这比跳进用户态中某个具体场景里挖掘信息具有普适性。

教授允许我们贴合题目自由发挥。我们想做的事情有二。

1. 动态监控内存的分配情况，更细节一点，监控堆内存的分配与释放。
2. 动态监控内存的使用频率，如果一段被分配的内存长期没有使用，那么它有可能*泄露*了。

通俗来讲，内存泄露指一块无用内存没有被及时释放。例如程序员用了一个结构体`struct Message {user_id, ctx}`来存储用户向服务器发送的指令。服务器在经过解析、计算、响应后，用户拿到了满意的结果，结束套接字连接，关机睡大觉去了。这是结构体实例就失去了存在的意义，应该被及时释放。如果它一天后、或一个月后、乃至一年后、甚至到机房停电服务器宕机时都一直没有被释放，那么我们说程序存在内存泄露的问题。

但是我们不可能笃定内存泄露正在发生。这是因为内存泄露本质上不能被运行时动态检测。

- 在程序运行时，我怎么知道将来某段数据会不会被使用？万一哪天就得用它了呢？
- 在程序运行时，我怎么知道这段数据会不会在下一秒被另一个函数给释放了？

不过从统计的角度来看，一段长时间未被使用的内存确实会给系统带来压力（占据了计算资源）。所以检测内存的使用频率也是实用的功能。

## 0x02 内存泄露的根源：堆内存的分配与释放

假设你要用 C 语言处理 1000 万个矩阵，每个矩阵的大小不定。这些矩阵无法被预处理，你只能硬着头皮把它们全部加载进内存。更糟糕的是，由于计算格外的复杂，在得到结果之前，它们必须一直保留在内存里，时刻准备好被读取。你可以选择数据的存储方式：

- ❌ 局部数组 `LocalList[]`。尽管运行时在栈上创建局部动态数组是 C99 支持的行为，但是你很难把它们持续的保存下来。
- ❌ 全局数组 `GlobalList[]`。如果使用一个被初始化的全局数组，它会存储在二进制程序中的数据段 (data section) 中，你会编译出一个巨大无比的可执行文件。如果使用一个未被初始化的全局数组，操作系统会帮你在运行之前申请好内存摆在那里。但是，使用全局数组必须要预先规定好数据的大小，所以它不适合存储我们的矩阵数据。
- ✅ 动态数组 `HeapList[]`。在程序的运行过程中测量每个矩阵的大小，在堆上动态分配内存存储它们。这听起来是不错的解决方案。

我们最终会选择动态数组，在堆上进行数据的存放。其原因是堆空间可以在运行期间动态分配，非常灵活。这也是程序员青睐“堆”的原因。事实上，如果我们用面向对象的语言（例如 C++）写这个程序，你会发现 `new` 操作符正是在堆上开辟空间存放实例。

虽然动态分配、灵活多变的堆内存听上去很不错，它也带来了困扰行业（尤其是巨头公司）几十年之久的问题，那就是内存泄露。

### 知识回顾：栈模式

程序的执行过程可以看做函数之间的相互调用。函数调用遵循“栈”的原则，也就是“后进先出”的原则：A 函数调用 B 函数，B 函数调用 C 函数，C 函数把计算结果返回给 B 函数，B 再处理一遍，最终告诉 A 函数。每个函数都对应一块内存用于存放数据，它们连在一起就是我们所谓的“栈内存空间”。

一个函数调用了返回指令后 (return)，它使用的栈空间就会自动释放。这是因为编译器确定了每个函数所占据的栈空间大小，并且自动向程序里插入了对栈帧 (sp) 寄存器的操纵指令。在运行期间，栈帧会自动移动，以开辟和释放栈内存。

![栈帧esp在调用和返回时移动](/images/malloc/stack_memory.png)

然而栈结构给复杂程序的编写带来了相当大的困难——在函数返回之前，栈帧都不能移动。例如，如果 D 函数想要使用 A 对应的内存空间（以下简称 A 内存）内部的第四条数据，它该怎么获得呢？

**方法一：** A 将数据作为参数传递给 B，B 再将数据作为参数传递给 C，C 也如此传递给 D。

**方法二：** 程序员计算好 A、B、C、D 三块内存的大小，并且通过 esp-(A+B+C+D)+4 的地址拿到数据。

**方法三：** 复制栈帧寄存器到另一个指针，模拟函数返回的过程进行“栈展开”操作，向前跳跃 3 次，最后根据偏移量拿到数据。

<Dialog>
这三个方法一个比一个离谱……
</Dialog>

三种方法都非常低效，而且稍不留神就会出错。

我们稍微拔高一点看问题：栈结构的观点是“函数拥有内存，内存属于函数”，所以将函数和内存牢牢绑定。程序员在实际编写代码的过程中，会发现通常内存与函数之间的联系没有这么紧密。有时候，一段内存需要在若干函数之间共享。于是，计算机科学家又引入了新的内存管理模式——堆。

<Callout title="👀 函数的副作用">
{`
引入堆之后，内存和函数“松绑”。内存不再是函数的附属产物，而是一块独立存在的可交互对象。这是计算机函数被广为诟病的一点——函数 y=f(x) 除了根据输入 x 得出输出 y 以外，竟然产生了副作用！严谨的数学家们不得不把计算机函数表达为 (y,S')=f(x,S) 的形式，其中 S 是一块拥有巨大值域的内存。这使得形式化验证计算机程序变得机器困难。\r\n
在图灵发明图灵机的时代，以邱奇为首的美国数学家发明了等价的λ演算，并最终延伸出了函数式编程语言。这是一种只允许栈模式的编程语言。它编写复杂，却拥有其他语言没有的优势。例如，由于不存在中间状态 S，函数式编程语言格外适合流模式、形式化验证和并发执行。\r\n
注意，函数式编程语言在实际运行中因为性能原因也使用堆内存。
`}
</Callout>

### 知识回顾：堆模式

堆的出现消除了函数之间共享数据的难点。堆内存在函数执行时开辟，大小不定。与栈模式的不同，尽管函数可以开辟堆内存，但它并不拥有这块内存，而是只拥有这块内存的**指针**。

![](/images/malloc/heap_memory.png)

正是因为这种特性，一块堆内存可以被很多函数同时使用（换句话说，很多函数都持有指向这块内存的指针）。编译器不敢贸然释放堆上的数据。因此程序员必须要亲自管理堆内存的释放。蹩脚的程序员很可能忘记（或懒得）释放内存，因此导致内存泄露。

<div className="flex flex-col space-y-2">
    <Dialog>
    其实程序可以找到时机自动释放堆内存？例如在没有指针指向它的时候？
    </Dialog>
    <DialogBack>
    没错，这就是语言运行时利用**引用计数**进行**垃圾回收**的原理。其实现代语言的编译器和运行时有很多方法帮助避免内存泄露。后续的系列文章我们会提到！
    </DialogBack>
</div>

在软件工程实践中，堆结构带来的影响更大。想象你的同事申请了一段堆内存，但是忘记将它的地址保存下来，或粗心地保存了其它地址。后续使用这段内存的代码可能错误地操作了其他内存单元，造成灾难性的后果。


## 0x03 绑定模型

<Callout title="📝 课堂笔记">
{`
我们刚才仔细地过了一遍堆栈内存管理模式。可以简单的总结一下：\r\n\r\n 
- 栈模式将函数与内存绑定，函数拥有内存，两者同生共死。\r\n\r\n 
- 堆模式将函数与内存松绑，函数拥有内存的指针，两者联系微弱。\r\n\r\n 
使用栈模式管理内存：\r\n\r\n 
- 好处是可以利用函数调用关系自动申请和释放内存\r\n\r\n
- 坏处是难以共享内存数据\r\n\r\n
使用堆模式管理内存：\r\n\r\n
- 好处是可以方便地在函数间共享数据\r\n\r\n
- 坏处是必须手动进行内存申请和释放，有可能引发内存泄漏\r\n\r\n
- 更糟糕的是引入了巨大的值域，破坏了函数的单一职责
`}
</Callout>

<Dialog>
    感谢这位前排同学的笔记。听课很认真。需要我帮你你写推荐信吗？
</Dialog>

堆栈模式各有利弊。它们的本质区别是函数与内存的**耦合程度**不同（即：函数-内存绑定关系的强弱不同）。我们花费一整篇文章的篇幅，终于得出了这个结论。现在，可以探讨内存管理模式的更多可能了。

### 绑定模型

栈模式中的函数与内存耦合最强。不妨称它为“强绑定模型”。堆模式中的函数与内存耦合较弱。不妨称它为“弱绑定模型”。那么，除了强、弱这两种绑定模型以外，有没有其他的绑定模型？

尽管从操作系统的层面来看，并不存在除了堆或栈以外的结构（有的操作系统甚至没有堆）。但是高级程序语言可以在编译期或运行期给程序添加更多的约束，从而实现不同的绑定模型。程序员也可以通过遵循各种编程范式，从而间接达到不同绑定模型的效果。

在弱绑定模型中（例如堆），我们只允许函数持有内存的指针，因此决定内存释放的时机非常关键。如果我们稍稍加强耦合关系，例如：允许某一函数（称为 MainActor）持有一块内存，并且可以针对这段内存签发具有不同权限的证书。其余的函数（称为 Actors）只能凭借证书读取或修改这段内存。MainActor 返回时，这块内存被自动销毁。这就是经典的“所有权”模型，又叫做单一可信源 (Single Source of Truth)。你经常能在数据驱动型程序（例如网页、手机APP）中看到这个模型的实践。

又比如，我们让内存只与特定的函数耦合：内存段在函数返回后移动到垃圾场，在一段时间后被特定函数集中销毁。这就是运行时垃圾回收(GC)机制。Java、Python、Go 等语言都在使用它。

此外还有非常多的绑定模型。我们将在后续的文章中慢慢接触它们。

## 总结

这篇文章主要探讨程序堆栈模式与内存管理的关系，即函数-内存耦合程度对内存管理带来的影响。在本系列的下一篇文章中，我们将从数据自身的角度，探讨“对象”与“生命周期”的概念。我们还将涉及更多有关内存安全性和垃圾回收机制的内容。

如果你喜欢这篇博客，可以通过 RSS 订阅更新。欢迎关注我的 GitHub 和推特账号，我将分享更多关于计算机系统安全的优质内容。如果你对这篇文章有任何疑问或建议，请在下方留言。再会~
