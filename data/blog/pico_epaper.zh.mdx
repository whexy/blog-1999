---
title: "ä½¿ç”¨ MicroPython åœ¨æ ‘è“æ´¾ Pico ä¸Šé©±åŠ¨å¾®é›ªå¢¨æ°´å±æ˜¾ç¤ºå™¨"
publishDate: 2025-02-10
summary: "ä½¿ç”¨æ ‘è“æ´¾ Pico é©±åŠ¨å¾®é›ªå¢¨æ°´å±æ˜¾ç¤ºå™¨ã€‚"
cat: Projects
lang: zh
---

å¢¨æ°´å±ï¼ˆåˆç§°"ç”µå­å¢¨æ°´"ï¼‰æ˜¾ç¤ºå™¨éå¸¸é€‚åˆä½åŠŸè€—å’Œæ—¥å…‰ä¸‹å¯è¯»çš„åº”ç”¨ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†å±•ç¤ºå¦‚ä½•å°† **800 Ã— 480** å¢¨æ°´å±è¿æ¥åˆ°æ ‘è“æ´¾ Picoï¼Œç„¶åé€šè¿‡ MicroPython ä»£ç æ˜¾ç¤ºå›¾åƒã€‚

## ç¡¬ä»¶è®¾ç½®

æˆ‘ä»¬å‡è®¾ï¼š

- ä¸€ä¸ªå…·æœ‰ SPI æ¥å£çš„å¾®é›ªé£æ ¼ 7.5â€³ å¢¨æ°´å±æ¨¡å—ï¼ˆåˆ†è¾¨ç‡ 800Ã—480ï¼‰ã€‚
- ä¸€ä¸ªè¿è¡Œ MicroPython çš„æ ‘è“æ´¾ Pico 2ã€‚

æˆ‘ä»¬éœ€è¦ä½¿ç”¨ Pico çš„ SPI æ¥å£ã€‚Pico 2 æœ‰ä¸¤ä¸ª SPI æ¥å£ï¼šSPI0 å’Œ SPI1ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ SPI0ã€‚è¯·å‚è§ä¸‹é¢çš„å¼•è„šå›¾ã€‚

![Pico 2 Pinout](images/Pico_2_R4_Pinout.svg)

ä»¥ä¸‹æ˜¯æˆ‘çš„å¼•è„šè¿æ¥ã€‚å¢¨æ°´å±é€šå¸¸æœ‰ä»¥ä¸‹ä¿¡å·ï¼š

| å¢¨æ°´å±å¼•è„š | æè¿°           | Pico SPI0 ç¤ºä¾‹å¼•è„š       |
| ---------- | -------------- | ------------------------ |
| VCC        | 3.3 V ç”µæº     | 3V3 (ä¾‹å¦‚ å¼•è„š 36)       |
| GND        | åœ°çº¿           | GND (ä¾‹å¦‚ å¼•è„š 38)       |
| DIN        | MOSI (SPI TX)  | SPI0 TX / GP7 (å¼•è„š 10)  |
| CLK        | SCLK (SPI CLK) | SPI0 SCK / GP6 (å¼•è„š 9)  |
| CS         | SPI CS         | SPI0 CSn / GP5 (å¼•è„š 7)  |
| DC         | æ•°æ®/å‘½ä»¤      | GP8 (å¼•è„š 11)            |
| RST        | å¤ä½           | SPI0 RST / GP9 (å¼•è„š 12) |
| BUSY       | å¿™ä¿¡å·         | GP10 (å¼•è„š 14)           |

<Callout title="GPIO è¯´æ˜" icon="ğŸ‘‰">
  å¯¹äº DCã€RSTã€BUSYï¼Œä½ å®é™…ä¸Šå¯ä»¥ä½¿ç”¨ä»»ä½•ä½ æƒ³è¦çš„
  GPIOã€‚æˆ‘åªæ˜¯éšæœºé€‰æ‹©äº† GP8ã€GP9ã€GP10ã€‚å½“ç„¶ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨å…¶ä»–
  GPIOï¼Œä½ éœ€è¦ç›¸åº”åœ°ä¿®æ”¹ä»£ç ã€‚
</Callout>

## Pico ä¸Šçš„ MicroPython è„šæœ¬

å°†ä»¥ä¸‹è„šæœ¬ï¼ˆä¾‹å¦‚ epaper_800x480.pyï¼‰é€šè¿‡ Thonny æˆ–ä»»ä½•å…¶ä»–æ–¹æ³•ä¿å­˜åˆ°ä½ çš„æ ‘è“æ´¾ Pico ä¸Šã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªé©±åŠ¨ç±»ï¼Œåˆå§‹åŒ–æ˜¾ç¤ºå™¨ï¼Œå¹¶å¯ä»¥æ˜¾ç¤ºå›¾åƒã€‚

```python
import machine
import time

# -------------------------------------------------------------------------
# 1) Display resolution for 7.5" e-paper (800 x 480)
# -------------------------------------------------------------------------
EPD_WIDTH  = 800
EPD_HEIGHT = 480

# -------------------------------------------------------------------------
# 2) Configure the Pico pins and SPI0
# -------------------------------------------------------------------------
#   GP6  = SCK
#   GP7  = MOSI
#   GP4  = MISO (not used but must assign a pin)
#   GP5  = CS
#   GP8  = DC
#   GP9  = RST
#   GP10 = BUSY
spi = machine.SPI(
    0,
    baudrate=2_000_000,
    polarity=0,
    phase=0,
    sck=machine.Pin(6),
    mosi=machine.Pin(7),
    miso=machine.Pin(4)
)

cs_pin   = machine.Pin(5,  machine.Pin.OUT, value=1)
dc_pin   = machine.Pin(8,  machine.Pin.OUT, value=0)
rst_pin  = machine.Pin(9,  machine.Pin.OUT, value=1)
busy_pin = machine.Pin(10, machine.Pin.IN)

def delay_ms(ms):
    time.sleep_ms(ms)

def digital_write(pin, val):
    pin.value(val)

def digital_read(pin):
    return pin.value()

def spi_write_block(data_block):
    spi.write(data_block)

# -------------------------------------------------------------------------
# 3) Eâ€Paper Driver Class
# -------------------------------------------------------------------------
class EPD_800x480:
    def __init__(self):
        self.width  = EPD_WIDTH
        self.height = EPD_HEIGHT
        self.reset_pin = rst_pin
        self.dc_pin    = dc_pin
        self.busy_pin  = busy_pin
        self.cs_pin    = cs_pin

    def hardware_reset(self):
        digital_write(self.reset_pin, 1)
        delay_ms(200)
        digital_write(self.reset_pin, 0)
        delay_ms(2)
        digital_write(self.reset_pin, 1)
        delay_ms(200)

    def send_command(self, cmd):
        digital_write(self.dc_pin, 0)  # Command
        digital_write(self.cs_pin, 0)
        spi_write_block(bytes([cmd]))
        digital_write(self.cs_pin, 1)

    def send_data(self, data):
        digital_write(self.dc_pin, 1)  # Data
        digital_write(self.cs_pin, 0)
        spi_write_block(bytes([data]))
        digital_write(self.cs_pin, 1)

    def send_data_block(self, data_block):
        digital_write(self.dc_pin, 1)
        digital_write(self.cs_pin, 0)
        spi_write_block(data_block)
        digital_write(self.cs_pin, 1)

    def read_busy(self):
        while digital_read(self.busy_pin) == 0:
            delay_ms(20)

    def turn_on_display(self):
        # Refresh
        self.send_command(0x12)
        delay_ms(100)
        self.read_busy()

    def init(self):
        """Initialize the display (power on, set registers, etc.).
           Make sure to match your eâ€paper's datasheet or Waveshare example code!
        """
        self.hardware_reset()

        # Example sequence (replace with your display's official sequence):
        #  - POWER SETTING
        #  - PANEL SETTING
        #  - TRES (resolution)
        #  - etc.
        # This is a placeholder; adapt to your hardware:
        self.send_command(0x01)  # POWER SETTING
        self.send_data(0x07)
        self.send_data(0x07)
        self.send_data(0x3f)
        self.send_data(0x3f)

        self.send_command(0x04)  # POWER ON
        delay_ms(100)
        self.read_busy()

        self.send_command(0x00)  # PANEL SETTING
        self.send_data(0x1F)

        # TRES: set resolution 800x480
        self.send_command(0x61)
        self.send_data(0x03)  # 800 >> 8
        self.send_data(0x20)  # 800 & 0xFF
        self.send_data(0x01)  # 480 >> 8
        self.send_data(0xE0)  # 480 & 0xFF

        self.send_command(0x15)
        self.send_data(0x00)

        self.send_command(0x50)
        self.send_data(0x10)
        self.send_data(0x07)

        self.send_command(0x60)
        self.send_data(0x22)

    # -- CHUNKED SENDING to save memory --
    def _send_zeros_in_chunks(self, total_size, chunk_size=512):
        zero_chunk = b'\x00' * chunk_size
        sent = 0
        while sent < total_size:
            remain = total_size - sent
            if remain >= chunk_size:
                self.send_data_block(zero_chunk)
                sent += chunk_size
            else:
                self.send_data_block(b'\x00' * remain)
                sent += remain

    def _send_inverted_data_in_chunks(self, data, chunk_size=512):
        idx = 0
        length = len(data)
        while idx < length:
            end = min(idx + chunk_size, length)
            slice_data = data[idx:end]
            inverted = bytearray(len(slice_data))
            for i, b in enumerate(slice_data):
                inverted[i] = ~b & 0xFF
            self.send_data_block(inverted)
            idx = end

    def display(self, black_buffer):
        """black_buffer is a bytes/bytearray of 48,000 bytes (800x480 // 8).
           We'll invert each byte on the fly, because the hardware often
           expects 1=white and 0=black.
        """
        size = (self.width * self.height) // 8

        # 1) Send old data (all white) in chunks
        self.send_command(0x10)
        self._send_zeros_in_chunks(size)

        # 2) Send new data (inverted)
        self.send_command(0x13)
        self._send_inverted_data_in_chunks(black_buffer)

        self.turn_on_display()

    def clear(self):
        """Clear the screen to white."""
        size = (self.width * self.height) // 8
        self.send_command(0x10)
        self._send_zeros_in_chunks(size)
        self.send_command(0x13)
        self._send_zeros_in_chunks(size)
        self.turn_on_display()

    def sleep(self):
        """Deep sleep / power off the display."""
        self.send_command(0x02)  # POWER OFF
        self.read_busy()
        self.send_command(0x07)  # DEEP_SLEEP
        self.send_data(0xA5)
        delay_ms(2000)

# -------------------------------------------------------------------------
# EXAMPLE USAGE
# -------------------------------------------------------------------------
def main():
    epd = EPD_800x480()
    epd.init()

    # Clear the screen
    epd.clear()

    # Suppose you uploaded an 800x480 BIN file to the Pico (flash),
    # containing 48,000 bytes of 1-bit data:
    with open("image_800x480.bin", "rb") as f:
        image_data = f.read()

    # Display it
    epd.display(image_data)

    # Wait a few seconds, then sleep
    delay_ms(5000)
    epd.sleep()

if __name__ == "__main__":
    main()
```

## å‡†å¤‡å›¾åƒ

ä½ éœ€è¦ä¸€ä¸ª 800Ã—480 åƒç´ çš„ 1 ä½ï¼ˆé»‘ç™½ï¼‰å›¾åƒã€‚åœ¨ä½ çš„æ¡Œé¢è®¡ç®—æœºä¸Šï¼ˆå¸¸è§„ Pythonï¼‰ï¼Œä½ å¯ä»¥ä½¿ç”¨ Pillow è½¬æ¢ä»»ä½•å½©è‰²å›¾åƒï¼š

```python
#!/usr/bin/env python3
import argparse
from PIL import Image

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--input",  "-i", required=True, help="Input image (png/jpg)")
    parser.add_argument("--output", "-o", required=True, help="Output bin file")
    args = parser.parse_args()

    # 1) Open and resize/crop your image to 800x480 if needed
    img = Image.open(args.input).convert("RGB")
    img = img.resize((800, 480))
    # 2) Convert to 1-bit
    bw_img = img.convert("1")  # uses dithering or pass dither=Image.NONE

    pixels = bw_img.load()
    width, height = bw_img.size
    buf = bytearray(width*height//8)

    idx = 0
    for y in range(height):
        for x_block in range(0, width, 8):
            b = 0
            for bitpos in range(8):
                px_val = pixels[x_block+bitpos, y]
                # px_val is 0 (black) or 255 (white) typically
                if px_val >= 128:
                    # White => bit=1
                    b |= (1 << (7 - bitpos))
            buf[idx] = b
            idx += 1

    with open(args.output, "wb") as f:
        f.write(buf)
    print(f"Saved {len(buf)} bytes to {args.output}")

if __name__ == "__main__":
    main()
```

è¿è¡Œæ–¹å¼ï¼š

```bash
python image_to_bin.py --input myphoto.png --output image_800x480.bin
```

å°† image_800x480.bin å¤åˆ¶åˆ° Picoï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ Thonny çš„ è§†å›¾ â†’ æ–‡ä»¶ï¼‰ã€‚

## åœ¨ Pico ä¸Šè¿è¡Œ

1. æ‰“å¼€ Thonnyï¼ˆæˆ–ä½ å–œæ¬¢çš„ MicroPython IDEï¼‰ã€‚
2. å°† `epaper_800x480.py` å¤åˆ¶åˆ°ä½ çš„æ¡Œé¢ã€‚
3. åŒæ—¶å°† `image_800x480.bin` å¤åˆ¶åˆ° Pico ä¸Šã€‚
4. è¿è¡Œ `epaper_800x480.py`ã€‚å®ƒåº”è¯¥åˆå§‹åŒ–æ˜¾ç¤ºå™¨ï¼Œæ¸…é™¤å®ƒï¼Œç„¶åæ˜¾ç¤ºä½ è½¬æ¢çš„å›¾åƒï¼

å¦‚æœä¸€åˆ‡æ­£å¸¸å·¥ä½œï¼Œä½ å°†åœ¨å¢¨æ°´å±ä¸Šçœ‹åˆ°ä½ çš„é»‘ç™½å›¾åƒã€‚

## å¸¸è§é—®é¢˜/æŠ€å·§

- å†…å­˜é”™è¯¯ï¼šå¦‚æœä½ çœ‹åˆ° `MemoryError: memory allocation failed`ï¼Œè¿™é€šå¸¸æ„å‘³ç€ä½ è¯•å›¾åˆ›å»ºä¸€ä¸ªå·¨å¤§çš„æ•°ç»„ã€‚ä¸Šé¢ä»£ç ä¸­çš„åˆ†å—æ–¹æ³•é¿å…äº†è¿™ä¸ªé—®é¢˜ã€‚
- é¢œè‰²åè½¬ï¼šå¦‚æœä½ çš„æ˜¾ç¤ºå™¨é¢œè‰²åè½¬äº†ï¼ˆç™½è‰²æ˜¯é»‘è‰²ï¼Œé»‘è‰²æ˜¯ç™½è‰²ï¼‰ï¼Œçœ‹çœ‹æ˜¯å¦éœ€è¦ç§»é™¤æˆ–ä¿®æ”¹ `~b & 0xFF` é€»è¾‘ã€‚
- å±€éƒ¨æ›´æ–°ï¼šä¸€äº›å¢¨æ°´å±æ”¯æŒå±€éƒ¨åˆ·æ–°ã€‚ä½ éœ€è¦æ›´é«˜çº§çš„åºåˆ—æ¥è¿›è¡Œå±€éƒ¨æ›´æ–°ã€‚
- ç¼“æ…¢ï¼šå¢¨æ°´å±åˆ·æ–°å¯èƒ½éœ€è¦ 2-3 ç§’æˆ–æ›´é•¿æ—¶é—´ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤§å‹æ˜¾ç¤ºå™¨ä¸Šã€‚è¿™æ˜¯æ­£å¸¸çš„ã€‚

## ç»“è®º

å°±æ˜¯è¿™æ ·ï¼ä½ å·²ç»æˆåŠŸåœ°ç”¨ MicroPython åœ¨æ ‘è“æ´¾ Pico ä¸Šé©±åŠ¨äº†ä¸€ä¸ªå¤§å‹ 7.5â€³ã€800Ã—480 å¢¨æ°´å±ã€‚å…³é”®æ˜¯å°†æ•°æ®åˆ†å°å—å‘é€ä»¥èŠ‚çœå†…å­˜ï¼Œå¹¶åœ¨ç¡¬ä»¶éœ€è¦æ—¶å³æ—¶åè½¬ä½ã€‚

å¢¨æ°´å±æä¾›äº†ä¸€ç§åä¸½çš„ã€ä½åŠŸè€—çš„æ–¹å¼æ¥æ˜¾ç¤ºé™æ€å›¾åƒã€æ ‡ç‰Œæˆ–ä»ªè¡¨æ¿ã€‚æ—¢ç„¶ä½ æœ‰äº†åŸºç¡€çŸ¥è¯†ï¼Œä½ å¯ä»¥æ‰©å±•åˆ°ç»˜åˆ¶æ–‡æœ¬ã€å½¢çŠ¶æˆ–å±€éƒ¨æ›´æ–°ã€‚

![Eâ€paper display](images/eink_demo.jpg)

ç¥ä½ åœ¨å¢¨æ°´å±å’Œ Pico çš„ç¼–ç¨‹ä¸­ç©å¾—æ„‰å¿«ï¼
